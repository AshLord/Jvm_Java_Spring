@HotSpotIntrinsicCandidate注解是特定于HotSpot虚拟机。它表明，一个带注解的方法可能(但不能保证是)由HotSpot VM内部进行的。如果HotSpot VM用手工编写的程序集和/或手工编写的编译器IR(一个编译器的内在特性)替换注解的方法来提高性能，那么就会引入一个方法。@HotSpotIntrinsicCandidate注解是Java库内部,因此应用程序代码不应该有任何关联。Java库的维护人员修改时必须考虑以下方法与@HotSpotIntrinsicCandidate注解。

    当与@HotSpotIntrinsicCandidate修改带注解的方法时,相应的内联函数代码在HotSpot VM实现必须更新以匹配的语义标注方法。

    对于一些带注解的方法，相应的内联函数可能会省略一些低级的检查，当然，如果使用Java字节码实现了内在特性，那么这些检查就会被执行。这是因为单个Java字节码隐式地检查了NullPointerException和ArrayStoreException异常。如果这种方法被汇编语言的内部编码所取代，那么在进入汇编代码之前，必须执行任何作为正常字节码操作的检查。这些检查必须在适当的情况下，在所有参数的内部，以及通过这些参数获得的其他值(如果有的话)上执行。可以通过检查方法的非内在Java代码来推断这些检查，并确定代码可能抛出哪些异常，包括未声明的隐式运行时异常。因此，根据内部的数据访问，检查可能包括:

        null检查引用
        范围检查用于数组索引的原始值。
        其他对原始值的有效性检查(例如，对于分零条件)
        存储对存储到数组中的引用值的检查。
        数组长度检查从内部索引的数组。
        引用类型转换(当形式参数为对象或其他弱类型时)

    注意，接收值(this)作为一个额外的参数传递给所有非静态方法。如果非静态方法是内联函数，则接收值不需要空检查，但是(如上所述)必须检查从对象字段中加载的任何值。出于代码清晰的考虑，最好是让内联函数成为静态的方法，以使这种依赖变得清晰。另外，最好在输入内部代码之前显式地从对象字段加载所有必需的值，并将这些值作为显式参数传递。首先，这可能是空检查(或其他检查)的必要条件。第二，如果内部从字段中重新加载值并在没有检查的情况下进行操作，那么竞态条件可能会将未检查的无效值引入到内部。如果内在需要将一个值存储回一个对象字段，那么该值应该显式地从内部返回;如果有多个返回值，编码器应该考虑在数组中缓冲它们。从本质上删除字段访问，不仅澄清了JVM和JDK之间的接口;它还有助于解耦HotSpot和JDK实现，因为如果JDK代码在内部管理所有的字段访问之前和之后，那么就可以将内部代码编写为不可知的对象布局。

    HotSpot VM的维护者在修改特性时必须考虑以下内容。
        当添加一个新的内在,确保相应的方法与@HotSpotIntrinsicCandidate Java库中的注解,所有可能的调用序列,导致调用内在包含的检查省略了内在的(如果有的话)。
        在修改现有的内部结构时，必须更新Java库，以匹配内部的语义，并执行内部(如果有的话)遗漏的所有检查。

    人没有直接参与维护Java库或HotSpot VM可以安全地忽略这一事实与@HotSpotIntrinsicCandidate带注解的方法。HotSpot VM在内部定义了一个特性列表。并非所有的内联函数都可以在HotSpot VM支持的所有平台上使用。此外，给定平台上的内联函数可用性取决于HotSpot VM的配置(例如，启用了VM标志集)。因此,注解方法@HotSpotIntrinsicCandidate并不保证intrinsified HotSpot VM的标记方法。如果启用了CheckIntrinsics VM标志,HotSpot VM检查装载类时(),(1)这个类的所有方法,也在VM的intrinsic与@HotSpotIntrinsicCandidate注解,(2)类的所有方法的注解与@HotSpotIntrinsicCandidate有一个内在的列表中。