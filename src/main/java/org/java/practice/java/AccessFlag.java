package org.java.practice.java;

/**
 * Created by 晋阳 on 2017/9/24.
 */
public abstract class AccessFlag {

    public void func0() {
        //共有方法 表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用
    }

    private void func1() {
        //私有方法 示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用。
    }

    protected void func2() {
        //对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。
    }

    static void fun3() {
        //static类能够被它自己使用，而不必引用特定的实例；static类能够在它的类的任何对象创建之前被访问，而不必引用任何对象
    }

    /**
     * 将方法声明为final那有两个原因，第一就是说明你已经知道这个方法提供的功能已经满足你要求，不需要进行扩展，
     * 并且也不允许任何从此类继承的类来覆写这个方法，但是继承仍然可以继承这个方法，也就是说可以直接使用。
     * 第二就是允许编译器将所有对此方法的调用转化为inline调用的机制，它会使你在调用final方法时，直接将
     * 方法主体插入到调用处，而不是进行例行的方法调用，例如保存断点，压栈等，这样可能会使你的程序效率有所提高，
     * 然而当你的方法主体非常庞大时，或你在多处调用此方法，那么你的调用主体代码便会迅速膨胀，可能反而会影响效率，
     * 所以你要慎用final进行方法定义。
     */
    final void fun4() {

    }

    synchronized void fun5() {
        //同步方法，一个线程如果想要调用该方法必须获得锁才能执行
    }

    /**
     * JAVA的native方法适用的情况：
     　　1、为了使用底层的主机平台的某个特性，而这个特性不能通过JAVA API访问。
     　　2、为了访问一个老的系统或者使用一个已有的库，而这个系统或这个库不是用JAVA编写的。
     　　3、为了加快程序的性能，而将一段时间敏感的代码作为本地方法实现。

     其实就是JNI。
     native是方法修饰符。Native方法是由另外一种语言（如c/c++，FORTRAN，汇编）实现的本地方法。
     因为在外部实现了方法，所以在java代码中，就不需要声明了，有点类似于借口方法。
     Native可以和其他一些修饰符连用，但是abstract方法和Interface方法不能用native来修饰。
     */
    native void fun6();

    /**
     抽象类不能被实例化。
     抽象方法是只有方法声明，而没有方法的实现内容。
     一个类中，只要有一个抽象方法，这个类必须被声明为抽象类
     抽象方法在非抽象子类中必须被重写。
     */
    abstract void fun7();

    /**
     * strict float point (精确浮点)
     * strictfp 关键字可应用于类、接口或方法。使用 strictfp 关键字声明一个方法时，该方法中所有的
     * float和double表达式都严格遵守FP-strict的限制,符合IEEE-754规范。
     * 当对一个类或接口使用 strictfp 关键字时，该类中的所有代码，包括嵌套类型中的初始设定值和代码，
     * 都将严格地进行计算。严格约束意味着所有表达式的结果都必须是 IEEE 754 算法对操作数预期的结果，
     * 以单精度和双精度格式表示。
     *
     * 如果你想让你的浮点运算更加精确，而且不会因为不同的硬件平台所执行的结果不一致的话，可以用关键字strictfp.
     */
    strictfp void fun8() {

    }

    /**
     * synthetic总的来说，是由编译器引入的字段、方法、类或其他结构，主要用于JVM内部使用，为了遵循某些规范
     * 而作的一些小技巧从而绕过这些规范，有点作弊的感觉，只不过是由编译器光明正大的，人为是没有权限的（但事实
     * 上有时候还是能被利用到的）。
     */
    void fun9() {
        this.getClass().isSynthetic();
    }

    public void execFun7() {
        fun7();
    }
}
